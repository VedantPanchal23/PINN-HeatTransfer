"""
Report generation for thermal analysis results.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from datetime import datetime
import json
from pathlib import Path


@dataclass
class ReportConfig:
    """Configuration for report generation."""
    title: str = "Thermal Analysis Report"
    author: str = "PINN Thermal Analyzer"
    include_summary: bool = True
    include_material_info: bool = True
    include_geometry_info: bool = True
    include_temperature_plots: bool = True
    include_validation: bool = True
    include_recommendations: bool = True
    
    logo_path: Optional[str] = None
    footer_text: str = "Generated by PINN Thermal Analysis Framework"


class ReportGenerator:
    """
    Generate comprehensive thermal analysis reports.
    
    Supports:
    - PDF reports with plots
    - HTML interactive reports
    - JSON data export
    """
    
    def __init__(self, config: ReportConfig = None):
        self.config = config or ReportConfig()
    
    def generate_pdf_report(
        self,
        results: Dict[str, Any],
        output_path: str,
    ):
        """
        Generate PDF report from analysis results.
        
        Args:
            results: Dictionary containing analysis results
                - temperature_field: 2D array
                - times: Time array
                - material_info: Material properties
                - thermal_limits: Limit analysis results
                - validation: Validation metrics
                - recommendations: Design recommendations
            output_path: Path for PDF output
        """
        with PdfPages(output_path) as pdf:
            # Title page
            self._add_title_page(pdf, results)
            
            # Executive summary
            if self.config.include_summary:
                self._add_summary_page(pdf, results)
            
            # Thermal limits and lifetime page
            if 'thermal_limits' in results:
                self._add_thermal_limits_page(pdf, results['thermal_limits'])
            
            # Material information
            if self.config.include_material_info and 'material_info' in results:
                self._add_material_page(pdf, results['material_info'])
            
            # Temperature plots
            if self.config.include_temperature_plots and 'temperature_field' in results:
                self._add_temperature_pages(pdf, results)
            
            # Validation results
            if self.config.include_validation and 'validation' in results:
                self._add_validation_page(pdf, results['validation'])
            
            # Recommendations
            if self.config.include_recommendations and 'recommendations' in results:
                self._add_recommendations_page(pdf, results['recommendations'])
        
        print(f"PDF report saved to: {output_path}")
    
    def _add_title_page(self, pdf: PdfPages, results: Dict):
        """Add title page to report."""
        fig = plt.figure(figsize=(8.5, 11))
        
        # Title
        fig.text(0.5, 0.7, self.config.title,
                 ha='center', va='center', fontsize=24, fontweight='bold')
        
        # Subtitle with date
        date_str = datetime.now().strftime("%Y-%m-%d %H:%M")
        fig.text(0.5, 0.62, f"Generated: {date_str}",
                 ha='center', va='center', fontsize=12, color='gray')
        
        # Key metrics box
        if 'temperature_field' in results:
            T = results['temperature_field']
            max_T = np.nanmax(T)
            mean_T = np.nanmean(T)
            
            metrics_text = [
                "Key Results:",
                f"â€¢ Maximum Temperature: {max_T:.1f}Â°C",
                f"â€¢ Mean Temperature: {mean_T:.1f}Â°C",
            ]
            
            if 'thermal_limits' in results:
                limits = results['thermal_limits']
                # Add geometry lifetime
                if hasattr(limits, 'geometry_lifetime') and limits.geometry_lifetime is not None:
                    if limits.geometry_lifetime == float('inf'):
                        metrics_text.append("â€¢ Geometry Lifetime: Indefinite (Stable)")
                    elif limits.geometry_lifetime < 60:
                        metrics_text.append(f"â€¢ Geometry Lifetime: {limits.geometry_lifetime:.1f}s")
                    elif limits.geometry_lifetime < 3600:
                        metrics_text.append(f"â€¢ Geometry Lifetime: {limits.geometry_lifetime/60:.1f} min")
                    else:
                        metrics_text.append(f"â€¢ Geometry Lifetime: {limits.geometry_lifetime/3600:.1f} hours")
                
                # Add time to melting
                if hasattr(limits, 'time_to_melting') and limits.time_to_melting is not None:
                    if limits.time_to_melting < 60:
                        metrics_text.append(f"â€¢ Time to Melting: {limits.time_to_melting:.1f}s âš ï¸")
                    elif limits.time_to_melting < 3600:
                        metrics_text.append(f"â€¢ Time to Melting: {limits.time_to_melting/60:.1f} min")
                    else:
                        metrics_text.append(f"â€¢ Time to Melting: {limits.time_to_melting/3600:.1f} hours")
                else:
                    metrics_text.append("â€¢ Time to Melting: Never (Safe)")
                
                # Add safety status
                if hasattr(limits, 'is_safe'):
                    status = "âœ… SAFE" if limits.is_safe else "âŒ UNSAFE"
                    metrics_text.append(f"â€¢ Status: {status}")
            
            y_pos = 0.45
            for line in metrics_text:
                fig.text(0.5, y_pos, line,
                        ha='center', va='center', fontsize=14)
                y_pos -= 0.04
        
        # Footer
        fig.text(0.5, 0.1, self.config.footer_text,
                 ha='center', va='center', fontsize=10, color='gray')
        
        plt.axis('off')
        pdf.savefig(fig)
        plt.close(fig)
    
    def _add_summary_page(self, pdf: PdfPages, results: Dict):
        """Add executive summary page."""
        fig = plt.figure(figsize=(8.5, 11))
        
        fig.text(0.5, 0.95, "Executive Summary",
                 ha='center', va='top', fontsize=18, fontweight='bold')
        
        summary_lines = [
            "This report presents the thermal analysis results using Physics-Informed",
            "Neural Networks (PINN) for transient heat transfer simulation.",
            "",
        ]
        
        # Add material info
        if 'material_info' in results:
            mat = results['material_info']
            summary_lines.extend([
                f"Material: {mat.get('name', 'Custom Mixture')}",
                f"Thermal Conductivity: {mat.get('thermal_conductivity', 'N/A'):.1f} W/(mÂ·K)",
                "",
            ])
        
        # Add geometry info
        if 'geometry_info' in results:
            geo = results['geometry_info']
            summary_lines.extend([
                f"Domain Size: {geo.get('width', 'N/A')} Ã— {geo.get('height', 'N/A')} m",
                f"Grid Resolution: {geo.get('nx', 'N/A')} Ã— {geo.get('ny', 'N/A')}",
                "",
            ])
        
        # Add thermal results
        if 'temperature_field' in results:
            T = results['temperature_field']
            summary_lines.extend([
                "Thermal Results:",
                f"  â€¢ Maximum Temperature: {np.nanmax(T):.1f}Â°C",
                f"  â€¢ Minimum Temperature: {np.nanmin(T):.1f}Â°C",
                f"  â€¢ Temperature Range: {np.nanmax(T) - np.nanmin(T):.1f}Â°C",
                "",
            ])
        
        # Write summary
        y_pos = 0.85
        for line in summary_lines:
            fig.text(0.1, y_pos, line, fontsize=11, va='top')
            y_pos -= 0.03
        
        plt.axis('off')
        pdf.savefig(fig)
        plt.close(fig)
    
    def _add_thermal_limits_page(self, pdf: PdfPages, thermal_limits):
        """Add thermal limits and geometry lifetime page."""
        fig = plt.figure(figsize=(8.5, 11))
        
        fig.text(0.5, 0.95, "ðŸ”¥ Thermal Limits & Geometry Lifetime",
                 ha='center', va='top', fontsize=18, fontweight='bold')
        
        y_pos = 0.85
        
        # Temperature limits section
        fig.text(0.1, y_pos, "Temperature Limits:", fontsize=14, fontweight='bold', va='top')
        y_pos -= 0.04
        
        if hasattr(thermal_limits, 'max_operating_temp'):
            fig.text(0.15, y_pos, f"â€¢ Max Operating Temperature: {thermal_limits.max_operating_temp:.1f}Â°C", fontsize=11, va='top')
            y_pos -= 0.03
        
        if hasattr(thermal_limits, 'melting_point'):
            fig.text(0.15, y_pos, f"â€¢ Melting Point: {thermal_limits.melting_point:.1f}Â°C", fontsize=11, va='top')
            y_pos -= 0.03
        
        if hasattr(thermal_limits, 'max_temperature_capacity') and thermal_limits.max_temperature_capacity:
            fig.text(0.15, y_pos, f"â€¢ Max Temperature Capacity: {thermal_limits.max_temperature_capacity:.1f}Â°C", fontsize=11, va='top')
            y_pos -= 0.03
        
        y_pos -= 0.02
        
        # Geometry Lifetime section
        fig.text(0.1, y_pos, "â±ï¸ Geometry Lifetime Analysis:", fontsize=14, fontweight='bold', va='top')
        y_pos -= 0.04
        
        if hasattr(thermal_limits, 'geometry_lifetime') and thermal_limits.geometry_lifetime is not None:
            if thermal_limits.geometry_lifetime == float('inf'):
                lifetime_str = "Indefinite (Stable at steady state)"
                color = 'green'
            elif thermal_limits.geometry_lifetime < 60:
                lifetime_str = f"{thermal_limits.geometry_lifetime:.1f} seconds âš ï¸ CRITICAL"
                color = 'red'
            elif thermal_limits.geometry_lifetime < 3600:
                lifetime_str = f"{thermal_limits.geometry_lifetime/60:.1f} minutes"
                color = 'orange'
            else:
                lifetime_str = f"{thermal_limits.geometry_lifetime/3600:.1f} hours"
                color = 'green'
            fig.text(0.15, y_pos, f"â€¢ Safe Operating Time: {lifetime_str}", fontsize=12, fontweight='bold', va='top', color=color)
            y_pos -= 0.04
        
        if hasattr(thermal_limits, 'time_to_melting'):
            if thermal_limits.time_to_melting is not None:
                if thermal_limits.time_to_melting < 60:
                    melt_str = f"{thermal_limits.time_to_melting:.1f} seconds âš ï¸ CRITICAL"
                    color = 'red'
                elif thermal_limits.time_to_melting < 3600:
                    melt_str = f"{thermal_limits.time_to_melting/60:.1f} minutes"
                    color = 'orange'
                else:
                    melt_str = f"{thermal_limits.time_to_melting/3600:.1f} hours"
                    color = 'green'
            else:
                melt_str = "Never (Temperature stays below melting point) âœ…"
                color = 'green'
            fig.text(0.15, y_pos, f"â€¢ Time Until Melting: {melt_str}", fontsize=12, fontweight='bold', va='top', color=color)
            y_pos -= 0.04
        
        if hasattr(thermal_limits, 'time_to_max_operating') and thermal_limits.time_to_max_operating is not None:
            if thermal_limits.time_to_max_operating < 60:
                time_str = f"{thermal_limits.time_to_max_operating:.1f} seconds"
            elif thermal_limits.time_to_max_operating < 3600:
                time_str = f"{thermal_limits.time_to_max_operating/60:.1f} minutes"
            else:
                time_str = f"{thermal_limits.time_to_max_operating/3600:.1f} hours"
            fig.text(0.15, y_pos, f"â€¢ Time to Max Operating Temp: {time_str}", fontsize=11, va='top')
            y_pos -= 0.03
        
        if hasattr(thermal_limits, 'lifetime_limiting_factor') and thermal_limits.lifetime_limiting_factor:
            fig.text(0.15, y_pos, f"â€¢ Limiting Factor: {thermal_limits.lifetime_limiting_factor}", fontsize=11, va='top')
            y_pos -= 0.03
        
        y_pos -= 0.02
        
        # Safety section
        fig.text(0.1, y_pos, "ðŸ›¡ï¸ Safety Analysis:", fontsize=14, fontweight='bold', va='top')
        y_pos -= 0.04
        
        if hasattr(thermal_limits, 'temp_margin'):
            fig.text(0.15, y_pos, f"â€¢ Safety Margin: {thermal_limits.temp_margin:.1f}Â°C", fontsize=11, va='top')
            y_pos -= 0.03
        
        if hasattr(thermal_limits, 'thermal_headroom') and thermal_limits.thermal_headroom is not None:
            fig.text(0.15, y_pos, f"â€¢ Thermal Headroom: {thermal_limits.thermal_headroom:.1f}%", fontsize=11, va='top')
            y_pos -= 0.03
        
        if hasattr(thermal_limits, 'safety_factor'):
            fig.text(0.15, y_pos, f"â€¢ Safety Factor: {thermal_limits.safety_factor:.2f}", fontsize=11, va='top')
            y_pos -= 0.03
        
        if hasattr(thermal_limits, 'risk_level'):
            risk_name = thermal_limits.risk_level.name if hasattr(thermal_limits.risk_level, 'name') else str(thermal_limits.risk_level)
            color = {'LOW': 'green', 'MEDIUM': 'orange', 'HIGH': 'red', 'CRITICAL': 'red'}.get(risk_name, 'black')
            fig.text(0.15, y_pos, f"â€¢ Risk Level: {risk_name}", fontsize=11, va='top', color=color)
            y_pos -= 0.03
        
        if hasattr(thermal_limits, 'is_safe'):
            status = "âœ… SAFE" if thermal_limits.is_safe else "âŒ UNSAFE"
            color = 'green' if thermal_limits.is_safe else 'red'
            fig.text(0.15, y_pos, f"â€¢ Overall Status: {status}", fontsize=12, fontweight='bold', va='top', color=color)
            y_pos -= 0.04
        
        # Warnings
        if hasattr(thermal_limits, 'warnings') and thermal_limits.warnings:
            y_pos -= 0.02
            fig.text(0.1, y_pos, "âš ï¸ Warnings:", fontsize=14, fontweight='bold', va='top', color='red')
            y_pos -= 0.04
            for warning in thermal_limits.warnings[:5]:  # Limit to 5
                fig.text(0.15, y_pos, f"â€¢ {warning}", fontsize=10, va='top', color='darkred')
                y_pos -= 0.03
                if y_pos < 0.1:
                    break
        
        plt.axis('off')
        pdf.savefig(fig)
        plt.close(fig)
    
    def _add_material_page(self, pdf: PdfPages, material_info: Dict):
        """Add material properties page."""
        fig = plt.figure(figsize=(8.5, 11))
        
        fig.text(0.5, 0.95, "Material Properties",
                 ha='center', va='top', fontsize=18, fontweight='bold')
        
        # Create table of properties
        properties = [
            ("Property", "Value", "Unit"),
            ("Thermal Conductivity", 
             f"{material_info.get('thermal_conductivity', 'N/A'):.1f}", "W/(mÂ·K)"),
            ("Density",
             f"{material_info.get('density', 'N/A'):.0f}", "kg/mÂ³"),
            ("Specific Heat",
             f"{material_info.get('specific_heat', 'N/A'):.0f}", "J/(kgÂ·K)"),
            ("Thermal Diffusivity",
             f"{material_info.get('thermal_diffusivity', 'N/A'):.2e}", "mÂ²/s"),
            ("Max Operating Temp",
             f"{material_info.get('max_operating_temp', 'N/A'):.0f}", "Â°C"),
        ]
        
        # Draw table
        ax = fig.add_axes([0.1, 0.5, 0.8, 0.35])
        ax.axis('off')
        
        table = ax.table(
            cellText=[p[1:] for p in properties[1:]],
            colLabels=("Value", "Unit"),
            rowLabels=[p[0] for p in properties[1:]],
            loc='center',
            cellLoc='center',
        )
        table.auto_set_font_size(False)
        table.set_fontsize(11)
        table.scale(1, 1.5)
        
        # Add composition if available
        if 'composition' in material_info:
            y_pos = 0.4
            fig.text(0.1, y_pos, "Material Composition:", fontsize=12, fontweight='bold')
            y_pos -= 0.03
            
            for mat, frac in material_info['composition'].items():
                fig.text(0.15, y_pos, f"â€¢ {mat}: {frac*100:.1f}%", fontsize=11)
                y_pos -= 0.025
        
        pdf.savefig(fig)
        plt.close(fig)
    
    def _add_temperature_pages(self, pdf: PdfPages, results: Dict):
        """Add temperature visualization pages."""
        T = results['temperature_field']
        
        # If 3D (time series), show key frames
        if T.ndim == 3:
            n_frames = min(4, T.shape[0])
            frame_indices = np.linspace(0, T.shape[0]-1, n_frames, dtype=int)
            
            fig, axes = plt.subplots(2, 2, figsize=(10, 10))
            fig.suptitle("Temperature Evolution", fontsize=16, fontweight='bold')
            
            times = results.get('times', np.arange(T.shape[0]))
            vmin, vmax = np.nanmin(T), np.nanmax(T)
            
            for ax, idx in zip(axes.flat, frame_indices):
                im = ax.imshow(
                    T[idx], cmap='hot', vmin=vmin, vmax=vmax,
                    origin='lower', aspect='equal'
                )
                ax.set_title(f't = {times[idx]:.3f}s')
                ax.set_xlabel('X')
                ax.set_ylabel('Y')
            
            fig.colorbar(im, ax=axes, label='Temperature (Â°C)', shrink=0.8)
            plt.tight_layout()
            pdf.savefig(fig)
            plt.close(fig)
            
        else:
            # Single time step
            fig, ax = plt.subplots(figsize=(10, 8))
            im = ax.imshow(T, cmap='hot', origin='lower', aspect='equal')
            ax.set_title("Temperature Field", fontsize=16, fontweight='bold')
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            plt.colorbar(im, label='Temperature (Â°C)')
            plt.tight_layout()
            pdf.savefig(fig)
            plt.close(fig)
    
    def _add_validation_page(self, pdf: PdfPages, validation: Dict):
        """Add validation results page."""
        fig = plt.figure(figsize=(8.5, 11))
        
        fig.text(0.5, 0.95, "Validation Results",
                 ha='center', va='top', fontsize=18, fontweight='bold')
        
        metrics_text = [
            "Comparison with Reference Solution:",
            "",
        ]
        
        if 'mse' in validation:
            metrics_text.append(f"â€¢ Mean Squared Error: {validation['mse']:.2e}")
        if 'rmse' in validation:
            metrics_text.append(f"â€¢ Root Mean Squared Error: {validation['rmse']:.2e}")
        if 'mae' in validation:
            metrics_text.append(f"â€¢ Mean Absolute Error: {validation['mae']:.2e}")
        if 'max_error' in validation:
            metrics_text.append(f"â€¢ Maximum Error: {validation['max_error']:.2e}")
        if 'relative_l2' in validation:
            metrics_text.append(f"â€¢ Relative L2 Error: {validation['relative_l2']*100:.2f}%")
        if 'correlation' in validation:
            metrics_text.append(f"â€¢ Correlation: {validation['correlation']:.4f}")
        
        y_pos = 0.8
        for line in metrics_text:
            fig.text(0.1, y_pos, line, fontsize=12, va='top')
            y_pos -= 0.035
        
        plt.axis('off')
        pdf.savefig(fig)
        plt.close(fig)
    
    def _add_recommendations_page(self, pdf: PdfPages, recommendations: List):
        """Add design recommendations page."""
        fig = plt.figure(figsize=(8.5, 11))
        
        fig.text(0.5, 0.95, "Design Recommendations",
                 ha='center', va='top', fontsize=18, fontweight='bold')
        
        y_pos = 0.85
        
        for rec in recommendations[:10]:  # Limit to 10
            if hasattr(rec, 'category'):
                header = f"[{rec.category.upper()}] {rec.title}"
            else:
                header = str(rec.get('title', 'Recommendation'))
            
            fig.text(0.1, y_pos, f"â€¢ {header}",
                    fontsize=12, fontweight='bold', va='top')
            y_pos -= 0.03
            
            description = getattr(rec, 'description', rec.get('description', ''))
            # Wrap text
            words = description.split()
            lines = []
            current_line = []
            for word in words:
                current_line.append(word)
                if len(' '.join(current_line)) > 70:
                    lines.append(' '.join(current_line[:-1]))
                    current_line = [word]
            lines.append(' '.join(current_line))
            
            for line in lines:
                fig.text(0.12, y_pos, line, fontsize=10, va='top', color='gray')
                y_pos -= 0.025
            
            y_pos -= 0.02
            
            if y_pos < 0.1:
                break
        
        plt.axis('off')
        pdf.savefig(fig)
        plt.close(fig)
    
    def generate_html_report(
        self,
        results: Dict[str, Any],
        output_path: str,
    ):
        """Generate interactive HTML report."""
        html_content = self._build_html(results)
        
        with open(output_path, 'w') as f:
            f.write(html_content)
        
        print(f"HTML report saved to: {output_path}")
    
    def _build_html(self, results: Dict) -> str:
        """Build HTML content for report."""
        html = f"""<!DOCTYPE html>
<html>
<head>
    <title>{self.config.title}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }}
        .container {{ max-width: 1000px; margin: auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        h1 {{ color: #2c3e50; border-bottom: 3px solid #e74c3c; padding-bottom: 10px; }}
        h2 {{ color: #34495e; margin-top: 30px; }}
        .metric {{ display: inline-block; background: #3498db; color: white; padding: 15px 25px; margin: 10px; border-radius: 8px; text-align: center; }}
        .metric .value {{ font-size: 24px; font-weight: bold; }}
        .metric .label {{ font-size: 12px; opacity: 0.8; }}
        table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
        th, td {{ border: 1px solid #ddd; padding: 12px; text-align: left; }}
        th {{ background: #3498db; color: white; }}
        tr:nth-child(even) {{ background: #f9f9f9; }}
        .recommendation {{ background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; margin: 10px 0; border-radius: 4px; }}
        .warning {{ background: #fee2e2; border-left: 4px solid #ef4444; }}
        .success {{ background: #d1fae5; border-left: 4px solid #10b981; }}
        .footer {{ margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; color: #7f8c8d; text-align: center; }}
    </style>
</head>
<body>
<div class="container">
    <h1>{self.config.title}</h1>
    <p style="color: #7f8c8d;">Generated: {datetime.now().strftime("%Y-%m-%d %H:%M")}</p>
"""
        
        # Key metrics
        if 'temperature_field' in results:
            T = results['temperature_field']
            max_T = np.nanmax(T)
            mean_T = np.nanmean(T)
            
            html += """
    <div style="margin: 20px 0;">
        <div class="metric">
            <div class="value">""" + f"{max_T:.1f}Â°C" + """</div>
            <div class="label">Maximum Temperature</div>
        </div>
        <div class="metric">
            <div class="value">""" + f"{mean_T:.1f}Â°C" + """</div>
            <div class="label">Mean Temperature</div>
        </div>
"""
            
            if 'thermal_limits' in results:
                limits = results['thermal_limits']
                # Safety Status
                if hasattr(limits, 'is_safe'):
                    status_color = '#10b981' if limits.is_safe else '#ef4444'
                    status_text = 'SAFE' if limits.is_safe else 'UNSAFE'
                    html += f"""
        <div class="metric" style="background: {status_color}">
            <div class="value">{status_text}</div>
            <div class="label">Safety Status</div>
        </div>
"""
                # Geometry Lifetime
                if hasattr(limits, 'geometry_lifetime') and limits.geometry_lifetime is not None:
                    if limits.geometry_lifetime == float('inf'):
                        lifetime_str = 'âˆž'
                        lifetime_color = '#10b981'
                    elif limits.geometry_lifetime < 60:
                        lifetime_str = f'{limits.geometry_lifetime:.1f}s'
                        lifetime_color = '#ef4444'
                    elif limits.geometry_lifetime < 3600:
                        lifetime_str = f'{limits.geometry_lifetime/60:.1f}min'
                        lifetime_color = '#f59e0b'
                    else:
                        lifetime_str = f'{limits.geometry_lifetime/3600:.1f}h'
                        lifetime_color = '#10b981'
                    html += f"""
        <div class="metric" style="background: {lifetime_color}">
            <div class="value">{lifetime_str}</div>
            <div class="label">Geometry Lifetime</div>
        </div>
"""
                # Max Temperature Capacity
                if hasattr(limits, 'max_temperature_capacity') and limits.max_temperature_capacity is not None:
                    html += f"""
        <div class="metric" style="background: #3b82f6">
            <div class="value">{limits.max_temperature_capacity:.0f}Â°C</div>
            <div class="label">Max Temp Capacity</div>
        </div>
"""
                # Thermal Headroom
                if hasattr(limits, 'thermal_headroom') and limits.thermal_headroom is not None:
                    headroom_color = '#10b981' if limits.thermal_headroom > 20 else '#f59e0b' if limits.thermal_headroom > 10 else '#ef4444'
                    html += f"""
        <div class="metric" style="background: {headroom_color}">
            <div class="value">{limits.thermal_headroom:.1f}%</div>
            <div class="label">Thermal Headroom</div>
        </div>
"""
            
            html += "    </div>\n"
        
        # Material info
        if 'material_info' in results:
            mat = results['material_info']
            html += """
    <h2>Material Properties</h2>
    <table>
        <tr><th>Property</th><th>Value</th><th>Unit</th></tr>
"""
            html += f"        <tr><td>Thermal Conductivity</td><td>{mat.get('thermal_conductivity', 'N/A'):.1f}</td><td>W/(mÂ·K)</td></tr>\n"
            html += f"        <tr><td>Density</td><td>{mat.get('density', 'N/A'):.0f}</td><td>kg/mÂ³</td></tr>\n"
            html += f"        <tr><td>Specific Heat</td><td>{mat.get('specific_heat', 'N/A'):.0f}</td><td>J/(kgÂ·K)</td></tr>\n"
            html += f"        <tr><td>Thermal Diffusivity</td><td>{mat.get('thermal_diffusivity', 0)*1e6:.2f}</td><td>mmÂ²/s</td></tr>\n"
            html += f"        <tr><td>Max Operating Temp</td><td>{mat.get('max_operating_temp', 'N/A'):.0f}</td><td>Â°C</td></tr>\n"
            if mat.get('min_melting_point'):
                html += f"        <tr><td>Melting Point</td><td>{mat.get('min_melting_point', 'N/A'):.0f}</td><td>Â°C</td></tr>\n"
            html += "    </table>\n"
        
        # Recommendations
        if 'recommendations' in results:
            html += "    <h2>Design Recommendations</h2>\n"
            for rec in results['recommendations'][:5]:
                title = getattr(rec, 'title', rec.get('title', 'Recommendation'))
                desc = getattr(rec, 'description', rec.get('description', ''))
                priority = getattr(rec, 'priority', rec.get('priority', 'medium'))
                
                css_class = "recommendation"
                if priority == 'high':
                    css_class += " warning"
                elif priority == 'low':
                    css_class += " success"
                
                html += f'    <div class="{css_class}"><strong>{title}</strong><br>{desc}</div>\n'
        
        html += f"""
    <div class="footer">
        {self.config.footer_text}
    </div>
</div>
</body>
</html>
"""
        
        return html
    
    def export_json(
        self,
        results: Dict[str, Any],
        output_path: str,
    ):
        """Export results to JSON format."""
        # Convert numpy arrays to lists
        export_data = {}
        
        for key, value in results.items():
            if isinstance(value, np.ndarray):
                export_data[key] = value.tolist()
            elif hasattr(value, '__dict__'):
                export_data[key] = {
                    k: v.tolist() if isinstance(v, np.ndarray) else v
                    for k, v in value.__dict__.items()
                }
            else:
                export_data[key] = value
        
        with open(output_path, 'w') as f:
            json.dump(export_data, f, indent=2, default=str)
        
        print(f"JSON data exported to: {output_path}")
